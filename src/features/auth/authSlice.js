import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import createUser, { checkAuth, loginUser, otpgeneration, resetPassword, resetPasswordRequest, signOut } from './authApi';
import { checkUser } from './authApi';
import { updateUser } from '../user/userApi';
const initialState = {
  loggedInUserToken:null,
  status: 'idle',
  error:null,
  userChecked:false ,
  // this below is basically that if mailSent is true means just tell the user that email is sent to your email just check and click the link to reset the password 
  mailSent:false,
  passwordReset:false,
  otp:null
};

export const createUserAsync = createAsyncThunk(
  'user/createUser',
  async (userData) => {
    const response = await createUser(userData);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const checkAuthAsync = createAsyncThunk(
  'user/checkAuth',
  async () => {
    try{const response = await checkAuth();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
    }catch(error){
      // here catch will only be executed if some above api call will be rejected so it will be rejected with the value which will come in the error section then by sending it to the predefined function rejectWithValue basically you are sending it to action.payload of extraReducers builder ke rejected waale case mai  then in that section you can easily send it to the state.error which is defined by use in the initialState 
      console.log(error)
      // dont forget to use return 
    }
  }
);
export const resetPasswordRequestAsync = createAsyncThunk(
  'user/resetPasswordRequest',
  async (email,{rejectWithValue}) => {
    try{const response = await resetPasswordRequest(email);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
    }catch(error){
      // here catch will only be executed if some above api call will be rejected so it will be rejected with the value which will come in the error section then by sending it to the predefined function rejectWithValue basically you are sending it to action.payload of extraReducers builder ke rejected waale case mai  then in that section you can easily send it to the state.error which is defined by use in the initialState 
      console.log(error)
      return rejectWithValue(error);
      // dont forget to use return 
    }
  }
);
export const loginUserAsync = createAsyncThunk(
  'user/loginUser',
  async (logInInfo,{rejectWithValue}) => {
    try{const response = await loginUser(logInInfo);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
    }catch(error){
      // here catch will only be executed if some above api call will be rejected so it will be rejected with the value which will come in the error section then by sending it to the predefined function rejectWithValue basically you are sending it to action.payload of extraReducers builder ke rejected waale case mai  then in that section you can easily send it to the state.error which is defined by use in the initialState 
      console.log(error)
      // dont forget to use return 
       return  rejectWithValue(error);
    }
  }
);
export const signOutAsync = createAsyncThunk(
  'user/signout',
  async () => {
    const response = await signOut();
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);
export const otpgenerationAsync = createAsyncThunk(
  'user/otpgeneration',
  async (email) => {
    const response = await otpgeneration(email);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);
export const resetPasswordAsync = createAsyncThunk(
  'user/resetPassword',
  async (data,{rejectWithValue}) => {
    try{
    const response = await resetPassword(data).catch(error => console.log(error));
    return response.data;
    }catch(error){
      console.log(error);
      // do always like reject with value to handle the error
      return rejectWithValue(error);
    }
  }
);


export const authSlice = createSlice({
  name: 'user',
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(createUserAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(createUserAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.loggedInUserToken = action.payload;
      })
      .addCase(loginUserAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(loginUserAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.loggedInUserToken = action.payload;
      })
      .addCase(loginUserAsync.rejected, (state , action) => {
        state.status = 'idle';
        state.error = action.payload;
      })
      .addCase(signOutAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(signOutAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        // now loggedInUserToken ka data bhi update ho jayega api mai update toh kar hi diya vahi se toh action.payload mai data aaya hai 
        state.loggedInUserToken=null;
      })
      .addCase(checkAuthAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(checkAuthAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        // now loggedInUserToken ka data bhi update ho jayega api mai update toh kar hi diya vahi se toh action.payload mai data aaya hai 
        state.loggedInUserToken=action.payload;
        state.userChecked =true;
      })
      .addCase(checkAuthAsync.rejected, (state) => {
        state.status = 'idle';
        state.userChecked =true;
      })
      .addCase(resetPasswordRequestAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(resetPasswordRequestAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.mailSent = true;
      })
      .addCase(resetPasswordAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(resetPasswordAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.passwordReset = true;
      })
      .addCase(resetPasswordAsync.rejected, (state , action) => {
        state.status = 'idle';
        // due to rejectwith value , error come in action.payload now appropriate error will be shown , because if you do not handle the rejected request so i do not know but automatically it was setting the passwordReset to true 
        state.error = action.payload;
      })
      .addCase(otpgenerationAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(otpgenerationAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.otp = action.payload;
        state.error = null;
      })
      .addCase(otpgenerationAsync.rejected, (state, action) => {
        state.status = 'idle';
        state.error = "User already exist";
      })
  },
});


export const authReducer =  authSlice.reducer;
