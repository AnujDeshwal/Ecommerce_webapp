import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import addToCart, { deleteItemFromCart, fetchItemsInCartByUserId,  resetCart,  updateItem } from './cartApi';

const initialState = {
 items:[],
  status: 'idle',
};

export const addToCartAsync = createAsyncThunk(
  'cart/addToCart',
  async (item) => {
    const response = await addToCart(item);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);
export const fetchItemsInCartByUserIdAsync = createAsyncThunk(
  'cart/fetchItemsInCartByUserId',
  async (userid) => {
    const response = await fetchItemsInCartByUserId(userid);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);
export const updateItemAsync = createAsyncThunk(
  // ya ye neeche waale naam hai saare different hone chahiye 
  'cart/updateItem',
  async (update) => {
    const response = await updateItem(update);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);
export const deleteItemFromCartAsync = createAsyncThunk(
  'cart/deleteItemFromCart',
  async (itemid) => {
    const response = await deleteItemFromCart(itemid);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
  );

  export const resetCartAsync = createAsyncThunk(
    // ya ye neeche waale naam hai saare different hone chahiye 
    'cart/resetCart',
    async (userid) => {
      console.log("this is resetCartAsync")
      const response = await resetCart(userid);
      // The value we return becomes the `fulfilled` action payload
      return response.status;
    }
  );
  
  
  export const addToCartSlice = createSlice({
  name: 'cart',
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(addToCartAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(addToCartAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.items.push( action.payload);
      })
      .addCase(fetchItemsInCartByUserIdAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(fetchItemsInCartByUserIdAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        // in this time we would not do like pushing one by one items to the cart because user can push more than one items in a cart but this time we are just assigning all items fetched from someone cart to its items list of cart 
        state.items=action.payload;
      })
      .addCase(updateItemAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(updateItemAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        const index = state.items.findIndex(item=>item.id===action.payload.id);
        state.items[index]=action.payload;
      })
      .addCase(deleteItemFromCartAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(deleteItemFromCartAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        const index = state.items.findIndex(item=>item.id===action.payload.id);
        state.items.splice(index,1);
      })
      .addCase(resetCartAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(resetCartAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        // items khali kar sakte ho becuase it belongs to particular user so if order is successfully placed mean cart ke sabhi item ka order ho gaya hai so hatado but mai cart ko hi empty kar de raha tha from the api which was bad approach because different users items were there ,not of particular user 
        state.items=[];
      })
  },
});



export const addToCartReducer = addToCartSlice.reducer;
